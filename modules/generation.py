from modules.tiles import Tiles
from modules.world import World
import numpy as np
import random

class Generation:
	def __init__(self, seed: int = None) -> None:
		self.seed = seed or random.randint(1,2147483647)

	def interpolant(self, t):
		return t*t*t*(t*(t*6 - 15) + 10)

	def generate_perlin_noise_2d(
		self, shape, res, tileable=(False, False)
	):
		"""Generate a 2D numpy array of perlin noise.
		Args:
			shape: The shape of the generated array (tuple of two ints).
				This must be a multple of res.
			res: The number of periods of noise to generate along each
				axis (tuple of two ints). Note shape must be a multiple of
				res.
			tileable: If the noise should be tileable along each axis
				(tuple of two bools). Defaults to (False, False).
			interpolant: The interpolation function, defaults to
				t*t*t*(t*(t*6 - 15) + 10).
		Returns:
			A numpy array of shape shape with the generated noise.
		Raises:
			ValueError: If shape is not a multiple of res.
		"""
		delta = (res[0] / shape[0], res[1] / shape[1])
		d = (shape[0] // res[0], shape[1] // res[1])
		grid = np.mgrid[0:res[0]:delta[0], 0:res[1]:delta[1]]\
				.transpose(1, 2, 0) % 1
		# Gradients
		angles = 2*np.pi*np.random.rand(res[0]+1, res[1]+1)
		gradients = np.dstack((np.cos(angles), np.sin(angles)))
		if tileable[0]:
			gradients[-1,:] = gradients[0,:]
		if tileable[1]:
			gradients[:,-1] = gradients[:,0]
		gradients = gradients.repeat(d[0], 0).repeat(d[1], 1)
		g00 = gradients[    :-d[0],    :-d[1]]
		g10 = gradients[d[0]:     ,    :-d[1]]
		g01 = gradients[    :-d[0],d[1]:     ]
		g11 = gradients[d[0]:     ,d[1]:     ]
		# Ramps
		n00 = np.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]  )) * g00, 2)
		n10 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]  )) * g10, 2)
		n01 = np.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]-1)) * g01, 2)
		n11 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]-1)) * g11, 2)
		# Interpolation
		t = self.interpolant(grid)
		n0 = n00*(1-t[:,:,0]) + t[:,:,0]*n10
		n1 = n01*(1-t[:,:,0]) + t[:,:,0]*n11
		return np.sqrt(2)*((1-t[:,:,1])*n0 + t[:,:,1]*n1)


	def generate_fractal_noise_2d(self,
			shape, res, octaves=1, persistence=0.5,
			lacunarity=2, tileable=(False, False),
			interpolant=interpolant
	):
		"""Generate a 2D numpy array of fractal noise.
		Args:
			shape: The shape of the generated array (tuple of two ints).
				This must be a multiple of lacunarity**(octaves-1)*res.
			res: The number of periods of noise to generate along each
				axis (tuple of two ints). Note shape must be a multiple of
				(lacunarity**(octaves-1)*res).
			octaves: The number of octaves in the noise. Defaults to 1.
			persistence: The scaling factor between two octaves.
			lacunarity: The frequency factor between two octaves.
			tileable: If the noise should be tileable along each axis
				(tuple of two bools). Defaults to (False, False).
			interpolant: The, interpolation function, defaults to
				t*t*t*(t*(t*6 - 15) + 10).
		Returns:
			A numpy array of fractal noise and of shape shape generated by
			combining several octaves of perlin noise.
		Raises:
			ValueError: If shape is not a multiple of
				(lacunarity**(octaves-1)*res).
		"""
		noise = np.zeros(shape)
		frequency = 1
		amplitude = 1
		for _ in range(octaves):
			noise += amplitude * self.generate_perlin_noise_2d(
				shape, (frequency*res[0], frequency*res[1]), tileable, interpolant
			)
			frequency *= lacunarity
			amplitude *= persistence
		return noise
	
	def generate(self, size_x: int, size_y: int, tiles: Tiles, seed: int = None) -> World:
		self.seed = seed or self.seed
		np.random.seed(self.seed)
		noise = self.generate_perlin_noise_2d((size_x,size_y), (8, 8))
		world = World(x=size_x, y=size_y, tiles=tiles)

		for y,yv in enumerate(noise):
			for x,xv in enumerate(noise):
				data = xv[y]
				if data >= 0.5:
					world.data[y][x] = 4
				elif data >= 0.3:
					world.data[y][x] = 3
				elif data <= -0.5:
					world.data[y][x] = 5
				else:
					world.data[y][x] = 6
		
		return world